# Implementation Plan: Eligibility Question Definitions API

**Branch**: `008-question-definitions-api` | **Date**: 2026-02-10 | **Spec**: [feature spec](spec.md)

**Input**: Feature specification from `Feature Specification: Eligibility Question Definitions API`

## Summary

The Eligibility Question Definitions API provides state- and program-specific question definitions to the frontend wizard interface, enabling personalized eligibility assessment flows. The API returns question metadata (field types, validation rules, options) and conditional visibility rules in a format the frontend can evaluate client-side. This is a critical P1 feature enabling the multi-step wizard pattern established in feature 007 (Wizard Session API).

**Core Capability**: Given a state code and program code, return complete question definitions with conditional visibility logic that the frontend can use to render a personalized questionnaire and determine which questions to display based on user answers.

**Technical Approach**: 
- Backend: Extend existing Domain/Application/API layers with Question/ConditionalRule entities and a `questions` endpoint
- Frontend: Hook to fetch question definitions, evaluate visibility rules against answer data
- Database: Add Question, ConditionalRule, QuestionOption tables to existing SessionContext
- Testing: Question evaluation logic unit-tested in isolation; conditional visibility rule evaluation 100% covered

---

## Technical Context

**Language/Version**: C# 13 (backend), TypeScript 5.x with React 18.x (frontend)  
**Primary Dependencies**: 
- Backend: ASP.NET Core 8.0, Entity Framework Core 8, Swashbuckle (OpenAPI)
- Frontend: React 18, Vite, Tailwind CSS, axios, React Query  

**Storage**: PostgreSQL 15.x (existing `SessionContext` extended with new tables)  
**Testing**: 
- Backend: xUnit with FluentAssertions, Moq for mocking
- Frontend: Vitest with React Testing Library for hooks and components  

**Target Platform**: Web (ASP.NET Core 8 API + React 18 SPA)  
**Project Type**: Existing monorepo with backend (`src/MAA.API`) and frontend (`frontend/`) folders  
**Performance Goals**: 
- Question retrieval endpoint: ≤200ms p95 for state/program combinations with up to 500 questions
- Frontend conditional evaluation: instant (client-side, <50ms)  

**Scale/Scope**: 
- Initially support 50 programs × 50 states = 2,500 state/program combinations
- Each combination may have 50-200 questions with conditional rules
- Total question definitions: ~10,000-20,000

---

## Constitution Check _(GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.)_

**Constitution Reference**: See [MAA Constitution](/.specify/memory/constitution.md) for full principle definitions.

### Principle Alignment Assessment

**✅ I. Code Quality & Clean Architecture**

- [x] Domain logic isolated from I/O: ConditionalRule evaluation logic can be unit-tested without database
- [x] Dependencies explicitly injected: Repository pattern for question data access, handlers in Application layer
- [x] Single responsibility classes: Question entity, QuestionValidator, ConditionalRuleEvaluator are single-purpose
- [x] DTO contracts explicitly defined: QuestionDto, ConditionalRuleDto, QuestionOptionDto in Application/DTOs
- [x] No God Objects: Question entity ~100 lines, ConditionalRuleEvaluator ~80 lines

**✅ II. Test-First Development**

- [x] Test scenarios from spec (3 user stories, all testable independently)
- [x] Unit tests: ConditionalRuleEvaluator tested with 100+ test cases (single/nested/AND-OR conditions)
- [x] Integration tests: IQuestionRepository.GetQuestionsAsync() tested with in-memory EF Core
- [x] API contract tests: GET `/api/questions/{stateCode}/{programCode}` endpoint validated against OpenAPI schema
- [x] All edge cases have tests: circular dependencies detection, invalid inputs, empty result sets
- [x] Coverage target: 85% Domain (Question/ConditionalRule), 75% Application (handlers)

**✅ III. UX Consistency & Accessibility (if user-facing)**

- This feature is backend API (not user-facing markup)
- Frontend integration ensures WCAG 2.1 AA compliance at consumption layer
- Question presentation (text, validation, help) defined in DTO format; markup generated by frontend components

**✅ IV. Performance & Scalability**

- [x] Response time SLO: ≤200ms p95 (per spec SC-001)
- [x] Caching: Question definitions cached in Redis with 24h TTL (immutable configuration data)
- [x] Database indexing: Composite index on (state_id, program_id) + individual indices on question_id
- [x] Client-side evaluation: Conditional rules evaluated in-browser (no backend round-trip per visibility check)
- [x] Load test target: 1,000 concurrent requests for question definitions (loadtest in Phase 2)

**⚠️ VIOLATIONS**: NONE - All principles satisfied ✅

---

## Project Structure

### Documentation (this feature)

```text
specs/008-question-definitions-api/
├── spec.md              # Feature specification (COMPLETE ✅)
├── plan.md              # This file (Phase 0-1 planning)
├── research.md          # Phase 0 output (research findings)
├── data-model.md        # Phase 1 output (entity design)
├── quickstart.md        # Phase 1 output (integration guide)
└── contracts/
    └── questions-api.openapi.yaml  # Phase 1 output (OpenAPI spec)
```

### Source Code (repository root) - EXISTING STRUCTURE LEVERAGED

```text
src/
├── MAA.Domain/          # ✅ EXISTING - Add Question, ConditionalRule, QuestionOption entities
├── MAA.Application/
│   ├── DTOs/            # ✅ EXISTING - Add QuestionDto, ConditionalRuleDto, QuestionOptionDto
│   └── Handlers/        # ✅ EXISTING - Add GetQuestionDefinitionsHandler (query handler)
├── MAA.Infrastructure/
│   ├── Data/
│   │   ├── SessionContext.cs  # ✅ EXISTING - Add DbSet properties for new entities
│   │   └── Migrations/        # New migration for question tables
│   └── Repositories/    # ✅ EXISTING - Add IQuestionRepository implementation
├── MAA.API/
│   ├── Controllers/     # ✅ EXISTING - Add QuestionsController (REST endpoint)
│   └── [Swagger auto-generated from endpoints]
└── MAA.Tests/           # ✅ EXISTING - Add QuestionDefinitionTests class

frontend/
├── src/
│   ├── components/
│   │   └── QuestionsLoader.tsx  # NEW - Fetch + display questions with conditional rules
│   ├── hooks/
│   │   └── useQuestions.ts      # NEW - React hook wrapping question fetch + conditional eval
│   └── services/
│       └── questionService.ts   # NEW - Axios service for /api/questions endpoint
└── tests/
    └── hooks/useQuestions.test.ts  # NEW - Vitest + React Testing Library tests
```

**Structure Decision**: Extend existing layered architecture (Domain/Application/Infrastructure/API + Frontend). No new projects required. All new code integrates into established patterns from features 001-007.

---

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|-----------|--------------------------------------|
| N/A | N/A | Feature passes all Constitution checks without exceptions |

---

## Phase 0: Research & Clarification (Dependency Resolution)

### Dependencies & Best Practices

#### 1. Conditional Rule Evaluation
- **Decision**: Implement rule evaluator as pure functions in Domain layer (testable without I/O)
- **Approach**: Boolean expression parser supporting AND/OR/NOT operators; variables bound to session answers
- **Rationale**: Enables unit testing in isolation; client-side evaluation possible (rule portable to frontend)
- **Alternatives Rejected**: Turing-complete scripting languages (too complex); database-driven evaluation (too slow)

#### 2. Question Caching Strategy
- **Decision**: Cache question definitions in Redis (24h TTL) keyed by `state:{stateCode}:program:{programCode}`
- **Approach**: Invalidate cache on question definition update (admin endpoint); fall back to database if cache miss
- **Rationale**: Question data immutable during user session; caching eliminates repeated database calls
- **Alternatives Rejected**: No caching (performance risk); application memory cache (doesn't survive app restart)

#### 3. Circular Dependency Detection
- **Decision**: Detect circular conditional rules at question registration time; raise validation error
- **Approach**: Topological sort of question dependency graph; prevent rules like Q1→Q2→Q1
- **Rationale**: Prevents frontend confusion; detected early in admin workflow (question upload)
- **Alternatives Rejected**: Runtime detection (too late; already rendered UI); ignore (silent failures)

#### 4. State/Program Code Validation
- **Decision**: Maintain master list of valid state codes (US@ABBR standard) and program codes; validate on API input
- **Approach**: Load reference data on app startup from configuration; cache in memory (small dataset)
- **Rationale**: Provides immediate 400 Bad Request for invalid inputs; prevents orphaned questions
- **Alternatives Rejected**: Call external service (too slow); skip validation (allows garbage data)

---

## Phase 1: Design & Contracts

### 1. Data Model

**Entities** (Domain Layer):

#### Question
```
- QuestionId: Guid (primary key)
- StateCode: string (US state: "CA", "TX", etc.)
- ProgramCode: string (program: "MEDI-CAL", "CALFRESH")
- DisplayOrder: int (position in question series)
- QuestionText: string (question shown to user)
- FieldType: QuestionFieldType enum (text, select, checkbox, radio, date, currency)
- IsRequired: bool
- HelpText: string? (optional guidance)
- ValidationRegex?: string (optional pattern for text fields)
- ConditionRuleId?: Guid (reference to optional visibility rule)
- CreatedAt: DateTime
- UpdatedAt: DateTime
```

#### ConditionalRule
```
- ConditionalRuleId: Guid
- RuleExpression: string (format: "question_1_id > 3 AND question_2_id == 'No'")
- CreatedAt: DateTime
- UpdatedAt: DateTime
```

#### QuestionOption
```
- OptionId: Guid
- QuestionId: Guid (foreign key)
- OptionLabel: string (display text: "Yes", "No", "Maybe")
- OptionValue: string (code: "yes", "no", "maybe")
- DisplayOrder: int
```

**Relationships**:
- Question → ConditionalRule (0..1 : 1) - optional visibility rule
- Question → QuestionOption (1 : *) - multiple options for select/checkbox/radio

### 2. API Contracts

**Endpoint**: `GET /api/questions/{stateCode}/{programCode}`

**Request**:
```
GET /api/questions/CA/MEDI-CAL
Headers: Authorization: Bearer {token}
```

**Response (200 OK)**:
```json
{
  "stateCode": "CA",
  "programCode": "MEDI-CAL",
  "questions": [
    {
      "questionId": "550e8400-e29b-41d4-a716-446655440000",
      "displayOrder": 1,
      "questionText": "What is your household size?",
      "fieldType": "text",
      "isRequired": true,
      "helpText": "Include all people you live with",
      "validationRegex": "^[0-9]+$",
      "conditionalRuleId": null
    },
    {
      "questionId": "550e8400-e29b-41d4-a716-446655440001",
      "displayOrder": 2,
      "questionText": "Do you have any dependents?",
      "fieldType": "select",
      "isRequired": false,
      "helpText": null,
      "conditionalRuleId": null,
      "options": [
        { "optionId": "...", "optionLabel": "Yes", "optionValue": "yes", "displayOrder": 1 },
        { "optionId": "...", "optionLabel": "No", "optionValue": "no", "displayOrder": 2 }
      ]
    },
    {
      "questionId": "550e8400-e29b-41d4-a716-446655440002",
      "displayOrder": 3,
      "questionText": "How many dependents?",
      "fieldType": "text",
      "isRequired": true,
      "helpText": null,
      "conditionalRuleId": "660f9511-f30c-52e5-b827-557766551111",
      "validationRegex": "^[0-9]+$"
    }
  ],
  "conditionalRules": [
    {
      "conditionalRuleId": "660f9511-f30c-52e5-b827-557766551111",
      "ruleExpression": "550e8400-e29b-41d4-a716-446655440001 == 'yes'",
      "description": "Show number of dependents only if answered 'Yes' to dependents question"
    }
  ]
}
```

**Error Response (400 Bad Request)**:
```json
{
  "error": "Invalid state code 'XX'",
  "code": "INVALID_STATE_CODE"
}
```

**Error Response (404 Not Found)**:
```json
{
  "error": "No questions defined for state 'CA' and program 'UNKNOWN_PROGRAM'",
  "code": "NO_QUESTIONS_FOUND"
}
```

### 3. Implementation Quickstart

#### Backend Integration (C# / ASP.NET Core)

```csharp
// 1. Domain Layer: Question entity + ConditionalRule
// File: src/MAA.Domain/Question.cs
public class Question
{
    public Guid QuestionId { get; set; }
    public string StateCode { get; set; }  // e.g., "CA"
    public string ProgramCode { get; set; } // e.g., "MEDI-CAL"
    public int DisplayOrder { get; set; }
    public string QuestionText { get; set; }
    public QuestionFieldType FieldType { get; set; }
    public bool IsRequired { get; set; }
    public string? HelpText { get; set; }
    public string? ValidationRegex { get; set; }
    public Guid? ConditionalRuleId { get; set; }
    public ConditionalRule? ConditionalRule { get; set; } // Navigation
    public ICollection<QuestionOption> Options { get; set; } = new List<QuestionOption>();
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public enum QuestionFieldType { Text, Select, Checkbox, Radio, Date, Currency }

// 2. Application Layer: Query + DTO
// File: src/MAA.Application/Queries/GetQuestionsQuery.cs
public record GetQuestionsQuery(string StateCode, string ProgramCode) : IRequest<GetQuestionsResult>;

public record GetQuestionsResult(
    string StateCode,
    string ProgramCode,
    List<QuestionDto> Questions,
    List<ConditionalRuleDto> ConditionalRules
);

// File: src/MAA.Application/DTOs/QuestionDto.cs
public record QuestionDto(
    Guid QuestionId,
    int DisplayOrder,
    string QuestionText,
    string FieldType,
    bool IsRequired,
    string? HelpText,
    string? ValidationRegex,
    Guid? ConditionalRuleId,
    List<QuestionOptionDto>? Options
);

// 3. API Controller
// File: src/MAA.API/Controllers/QuestionsController.cs
[ApiController]
[Route("api/questions")]
public class QuestionsController : ControllerBase
{
    private readonly IMediator _mediator;

    [HttpGet("{stateCode}/{programCode}")]
    [ProducesResponseType(typeof(GetQuestionsResult), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetQuestionDefinitions(string stateCode, string programCode)
    {
        var query = new GetQuestionsQuery(stateCode, programCode);
        var result = await _mediator.Send(query);
        return Ok(result);
    }
}

// 4. Infrastructure: Database Migration
// File: src/MAA.Infrastructure/Migrations/[timestamp]_AddQuestionDefinitions.cs
// EF Core migration adds Question, ConditionalRule, QuestionOption tables
// Composite index on (state_code, program_code) for fast lookup
// Foreign key: question.conditional_rule_id → conditional_rule.id
```

#### Frontend Integration (TypeScript / React)

```typescript
// 1. React Hook: useQuestions
// File: frontend/src/hooks/useQuestions.ts
export function useQuestions(stateCode: string, programCode: string) {
  return useQuery({
    queryKey: ['questions', stateCode, programCode],
    queryFn: () => questionService.getQuestions(stateCode, programCode),
    staleTime: 24 * 60 * 60 * 1000, // Cache for 24 hours
  });
}

// 2. Conditional Visibility Evaluator
// File: frontend/src/lib/evaluateConditionalRules.ts
export function evaluateVisibility(
  question: QuestionDto,
  answers: Record<string, string | number | boolean>,
  rules: ConditionalRuleDto[]
): boolean {
  if (!question.conditionalRuleId) return true; // Always visible if no rule

  const rule = rules.find(r => r.conditionalRuleId === question.conditionalRuleId);
  if (!rule) return true;

  // Parse rule: "550e8400-e29b-41d4-a716-446655440001 == 'yes'"
  return evaluateExpression(rule.ruleExpression, answers);
}

// 3. Component usage
// File: frontend/src/components/QuestionsLoader.tsx
export function QuestionsLoader({ stateCode, programCode, answers, onAnswerChange }: Props) {
  const { data, isLoading, error } = useQuestions(stateCode, programCode);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorAlert message={error.message} />;

  return (
    <form>
      {data?.questions.map(question => {
        const isVisible = evaluateVisibility(question, answers, data.conditionalRules);
        if (!isVisible) return null;

        return <QuestionInput key={question.questionId} question={question} />;
      })}
    </form>
  );
}
```

---

## Success Metrics (Post-Implementation)

1. **SC-001**: ✅ Question retrieval responds < 200ms p95 (measured via Application Insights)
2. **SC-002**: ✅ 100% of defined state/program combos return all questions
3. **SC-003**: ✅ Conditional rule evaluation passes 100 test cases (unit test coverage)
4. **SC-004**: ✅ Frontend renders all question types without additional API calls
5. **SC-005**: ✅ Edge cases (invalid inputs, deprecated programs) handled gracefully
6. **SC-006**: ✅ Audit logs capture all question access requests

---

## Next Steps

**Phase 2** (not created by `/speckit.plan`): `/speckit.tasks` generates implementation task list
- Backend: Domain entities, repository, query handler, API controller, migrations
- Frontend: React hook, conditional evaluator, component integration
- Testing: Unit tests (ConditionalRuleEvaluator, 100+ cases), integration tests (repository), E2E tests (API contract)
- Documentation: Update Swagger, API versioning guide, testing guide

**Approve** plan and proceed with `/speckit.tasks` for detailed task breakdown and implementation guidance.
